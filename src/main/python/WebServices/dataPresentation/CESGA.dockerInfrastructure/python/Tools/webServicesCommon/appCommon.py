import sys
import os


if 'config' in sys.modules:
  config= sys.modules['config']
else:
  import config as config

config.logger.debug('{} using config from {}'.format(os.path.basename(__file__), config.__file__))
  # print ('You have not imported the {} module'.format(modulename))

from flask.json import jsonify
from flask_futureExecutor import Executor
from datetime import date, timedelta, datetime
# from fastapi.encoders import jsonable_encoder

from gevent.pywsgi import WSGIServer
# from flask import request
from flask import Flask
# from flask import abort
# from datetime import date, datetime
from flasgger import Swagger

import logging
logger= config.logger
logger.debug("ENV VARS: {}".format(os.environ))
logger.info("{} server has started on {} with sys.path=\n\t{}".format(os.path.basename(__file__), str( datetime.now()), sys.path))


class AppBaseClass(object):
    def __init__(self, app, prefix=""):
        self.app = app
        self.prefix = prefix

    def __call__(self, environ, start_response):

        if environ["PATH_INFO"].startswith(self.prefix):
            environ["PATH_INFO"] = environ["PATH_INFO"][len(self.prefix) :]
            environ["SCRIPT_NAME"] = self.prefix
            rc= self.app(environ, start_response)
            return rc
        else:
            start_response("404", [("Content-Type", "text/plain")])
            return ["This url does not belong to the app.".encode()]


app = Flask(__name__)
app.config.from_pyfile(config.__file__)

# Swagger library described here: https://github.com/flasgger/flasgger
# swagger = Swagger(app, template=config.swagger_template, config=config.swagger_config)
executor = Executor(app, config.future_timeAliveSgs, logger)


@app.route('/healthCheck', methods=['GET'], )
def healthCheck():
    """
    Returns current date as a ACK signal
    ---
    tags:
      - management
    responses:
      200:
        description: current date as a ACK signal
    """
    return jsonify( str( datetime.now()))

@app.route('/job/<id>', methods=['GET'])
def getJobStatus(id):
    """Gets the status of the job with the given <id>
    NOTE: Jobs are generated by the invocation of asynchronous tasks with an unique identifier.
    ---
    tags:
      - management
    parameters:
      - name: id
        description: Unique identifier of the job
        in: path
        type: string
        required: true
        default: na
    responses:
      200:
        description: Status of the job
    examples:
        /job/c642b2fc-539c-11ec-b8ea-0050569f07f0
    """
    return jsonify(executor.jobStatus(id))


@app.route('/jobs', methods=['GET'])
def getJobsStatus():
    """Returns an array with the status of all launched jobs (jobs already finished and seen are removed after the number of seconds defined in the config param future_timeAliveSgs)
    NOTE: Jobs are generated by the invocation of asynchronous tasks with an unique identifier.
    ---
    tags:
      - management
    responses:
      200:
        description: Array with the status of all launched jobs.
    """
    # logger.debug(executor.jobsStatus())
    return jsonify(executor.jobsStatus())

def launchServer():
    port = int(sys.argv[1]) if len(sys.argv) > 1 else config.serverPort
    root = sys.argv[2] if len(sys.argv) > 2 and sys.argv[2] else ""
    app.wsgi_app = AppBaseClass(app.wsgi_app, prefix=root)
    server = WSGIServer(("0.0.0.0", port), app)
    try:
        logger.info(
            f"Serving on port {port}"
            + (f" and application root '{root}'..." if root else "...")
        )

        
        server.serve_forever()
    except Exception as e:
        logger.info("Unexpected error:" + str(sys.exc_info()).replace('"', '~')) # To avoid errors formatting jsons
        exit(-1)

# Next lines must be copied at the end of the main appServer
# if __name__ == "__main__":
#    appCommon.launchServer()
